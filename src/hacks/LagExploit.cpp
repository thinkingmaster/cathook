/*
 * LagExploit.cpp
 *
 *  Created on: May 7, 2017
 *      Author: nullifiedcat
 */

#include <hacks/LagExploit.hpp>
#include <hacks/Announcer.hpp>
#include "common.hpp"

namespace hacks
{
namespace shared
{
namespace lagexploit
{

static CatVar toggle(CV_SWITCH, "se_toggle", "0", "toggle",
                     "Toggle sequence exploit");
static CatVar shoot(CV_SWITCH, "se_shoot", "0", "Instant revvup/shoot",
                    "Instant revvup/shoot two shots at once");

// SHOUTOUTS TO BLACKFIRE
static CatVar doom(CV_SWITCH, "se_doom", "0", "Shoot 2+ shots at once",
                   "See Center string on activation.");
static CatVar piss(CV_SWITCH, "se_piss", "0", "Piss", "Spam Jarate");
static CatVar razorback(CV_SWITCH, "se_antirazorback", "0", "Anti-Razorback",
                        "Stab through razorbacks");
static CatVar stickyspam(CV_SWITCH, "se_stickyspam", "0", "Sticky spam",
                         "Allows Spam of stickies simply by holding Mouse1.");
static CatVar
    infinitecharge(CV_SWITCH, "se_infinite_charge", "0",
                   "Infinite sticky charge",
                   "Infinitely charge stickies, (can be used for sniping "
                   "and or b1g dmg using the quickiebomb launcher)");
static CatVar cloak(CV_SWITCH, "se_cloak", "0", "Instant decloak/cloak", "");
static CatVar cap(CV_SWITCH, "se_cap", "0", "Auto instant cap", "");
static CatVar cart(CV_SWITCH, "se_cart", "0", "Farm cart points",
                   "Automatically farm points by touching "
                   "the cart (only works on attacking "
                   "team)");
static CatVar instant_weapon_switch(CV_SWITCH, "se_switch", "0",
                                    "Instant weapon switch", "");
static CatVar key(CV_KEY, "se_key", "0", "Sequence exploit key");
static CatVar weaponswitch(CV_KEY, "se_switch_key", "0",
                           "Switch spam key (for gru) key");
static CatVar delay1(CV_INT, "se_switch_delay1", "0",
                     "Delay before switching to melee");
static CatVar delay2(CV_INT, "se_switch_delay2", "0",
                     "Delay before switching to Primary");
static CatVar
    master_switch(CV_SWITCH, "se_master", "1", "Enable sequence exploit",
                  "Master switch for the sequence exploit\nDisabling this "
                  "disables everything else that uses it");
static CatVar value(CV_INT, "se_value", "900", "Sequence exploit value",
                    "Value of user cmds to spam with");
static CatVar
    cap_range(CV_FLOAT, "se_cap_range", "200.0f", "Autocap range",
              "Autocap range, increase if you notice that you only lagy "
              "once you are already in the cap zone");
CatCommand do_lagexploit("se_do", "Sequence exploit (for use in scripts)",
                         []() { AddExploitTicks(6); });
int exticks                = 0;
const model_t *pointarr[5] = { nullptr, nullptr, nullptr, nullptr, nullptr };
bool bcalled               = false;
void AddExploitTicks(int ticks)
{
    exticks = std::max(ticks, exticks);
}
bool active = false;
bool ExploitActive()
{
    if (toggle)
        return true;
    if (exticks > 0)
    {
        return true;
    }
    if (g_IInputSystem->IsButtonDown((ButtonCode_t)((int) key)))
    {
        return true;
    }
    if (active)
        return true;
    return false;
}

static CatVar infinite_packs(CV_SWITCH, "infinite_packs", "0",
                             "Infinite Pickups",
                             "Activate sequence exploit when standing on "
                             "pickups while having not full HP/Ammo");
float servertime, nextattack, nextattack2;
static int lastwep = 0;
void CreateMove()
{
    active = false;
    if (CE_BAD(LOCAL_E))
        return;
    if (!LOCAL_E->m_bAlivePlayer)
        return;
    if (exticks > 0)
        exticks--;

    if (!exticks)
    {
        // Infinite pickups (health and ammo)
        if (infinite_packs && CE_GOOD(LOCAL_E))
        {
            ICollideable *p = RAW_ENT(LOCAL_E)->GetCollideable();
            const Vector &max1 =
                p->OBBMaxs() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
            const Vector &min1 =
                p->OBBMins() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
            for (int i = 1; i < entity_cache::max; i++)
            {
                CachedEntity *e = ENTITY(i);
                // CE_BAD is used to prevent removeconding on empty spaces where
                // the item hasn't respawned Class check to ensure entity is
                // pickup item
                if (CE_BAD(e) || e->m_iClassID != CL_CLASS(CBaseAnimating))
                {
                    continue;
                }

                ICollideable *c = RAW_ENT(e)->GetCollideable();

                // Bounds check
                const Vector &max2 =
                    c->OBBMaxs() + e->m_vecOrigin + Vector(8, 8, 8);
                const Vector &min2 =
                    c->OBBMins() + e->m_vecOrigin - Vector(8, 8, 8);
                if ((min1.x <= max2.x && max1.x >= min2.x) &&
                    (min1.y <= max2.y && max1.y >= min2.y) &&
                    (min1.z <= max2.z && max1.z >= min2.z))
                {
                    // logging::Info("Collision with %d", i);

                    // Lag for health
                    if (LOCAL_E->m_iHealth < LOCAL_E->m_iMaxHealth &&
                        (e->m_ItemType == ITEM_HEALTH_SMALL ||
                         e->m_ItemType == ITEM_HEALTH_MEDIUM ||
                         e->m_ItemType == ITEM_HEALTH_LARGE))
                    {
                        AddExploitTicks(3);
                    }
                    // Lag for ammo / metal
                    // TODO: Alternative to - LOCAL_E->m_iAmmo <
                    // LOCAL_E->m_iMaxAmmo That is pseudocode but checking each
                    // weapon for ammo + engie for metal would be ideal
                    if (CE_INT(g_pLocalPlayer->weapon(), netvar.m_iAmmo) < 5 &&
                        (e->m_ItemType == ITEM_AMMO_SMALL ||
                         e->m_ItemType == ITEM_AMMO_MEDIUM ||
                         e->m_ItemType == ITEM_AMMO_LARGE))
                    {
                        AddExploitTicks(3);
                    }
                }
            }
        }
    }

    // Previously was in GetUserCmd
    // Thanks Blackfire for helping me improve removecond!

    if (!g_pUserCmd)
        return;
    if (!g_pUserCmd->command_number)
        return;
    int amount = 0;
    if (!bcalled)
        for (int i = 1; i < HIGHEST_ENTITY; i++)
        {
            CachedEntity *pEnt = ENTITY(i);
            if (!CE_GOOD(pEnt))
                continue;
            const model_t *model = RAW_ENT(pEnt)->GetModel();
            if (!model)
                continue;
            const char *model_name = g_IModelInfo->GetModelName(model);
            if (strstr("models/props_gameplay/cap_point_base.mdl", model_name))
                pointarr[0] = model;
            if (strstr("models/props_trainyard/bomb_cart.mdl", model_name))
                pointarr[1] = model;
            if (strstr("models/props_2fort/trainwheel001.mdl", model_name))
                pointarr[2] = model;
            if (strstr("models/custom/dirty_bomb_cart.mdl", model_name))
                pointarr[3] = model;
            if (strstr("models/props_trainyard/bomb_cart_red.mdl", model_name))
                pointarr[4] = model;
        }
    bcalled = true;
    if (cart)
    {
        for (int i = 1; i < HIGHEST_ENTITY; i++)
        {
            if (!pointarr[1] && !pointarr[2] && !pointarr[3] && !pointarr[4])
                continue;
            CachedEntity *pEnt = ENTITY(i);
            if (!CE_GOOD(pEnt))
                continue;
            if (pEnt->m_iTeam == LOCAL_E->m_iTeam)
                continue;
            const model_t *model = RAW_ENT(pEnt)->GetModel();
            if (!model)
                continue;
            if (model == pointarr[1] || model == pointarr[2] ||
                model == pointarr[3] || model == pointarr[4])
            {
                if (!CE_GOOD(LOCAL_E))
                    continue;
                ICollideable *c = RAW_ENT(pEnt)->GetCollideable();
                ICollideable *p = RAW_ENT(LOCAL_E)->GetCollideable();
                const Vector &max1 =
                    p->OBBMaxs() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
                const Vector &min1 =
                    p->OBBMins() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
                const Vector &max2 =
                    c->OBBMaxs() + pEnt->m_vecOrigin + Vector(25, 25, 25);
                const Vector &min2 =
                    c->OBBMins() + pEnt->m_vecOrigin - Vector(25, 25, 25);
                if ((min1.x <= max2.x && max1.x >= min2.x) &&
                    (min1.y <= max2.y && max1.y >= min2.y) &&
                    (min1.z <= max2.z && max1.z >= min2.z))
                {
                    amount = 50;
                }
            }
        }
    }
    if (!master_switch)
        return;
    if (weaponswitch.KeyDown())
    {
        static int aa = 0, bb = 0;
        if (aa > (int) delay1)
        {
            g_IEngine->ExecuteClientCmd("slot1");
            aa = 0;
        }
        if (bb > (int) delay1 + (int) delay2)
        {
            g_IEngine->ExecuteClientCmd("slot3");
            bb = 0;
        }
        aa++;
        bb++;
    }
    static bool bWasHolding = false;
    bool bIsHolding         = ((g_pUserCmd->buttons & IN_ATTACK) ||
                       (g_pUserCmd->buttons & IN_ATTACK2));

    if (cap)
    {
        for (int i = 1; i < HIGHEST_ENTITY; i++)
        {
            if (!pointarr[0])
                continue;
            CachedEntity *pEnt = ENTITY(i);
            if (!CE_GOOD(pEnt))
                continue;
            if (pEnt->m_iTeam == LOCAL_E->m_iTeam)
                continue;
            const model_t *model = RAW_ENT(pEnt)->GetModel();
            if (!model)
                continue;
            if (model == pointarr[0])
            {
                if (!CE_GOOD(LOCAL_E))
                    continue;
                ICollideable *c = RAW_ENT(pEnt)->GetCollideable();
                ICollideable *p = RAW_ENT(LOCAL_E)->GetCollideable();
                const Vector &max1 =
                    p->OBBMaxs() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
                const Vector &min1 =
                    p->OBBMins() + RAW_ENT(LOCAL_E)->GetAbsOrigin();
                const Vector &max2 =
                    c->OBBMaxs() + pEnt->m_vecOrigin +
                    Vector((float) cap_range, (float) cap_range,
                           (float) cap_range);
                const Vector &min2 =
                    c->OBBMins() + pEnt->m_vecOrigin -
                    Vector((float) cap_range, (float) cap_range,
                           (float) cap_range);
                if ((min1.x <= max2.x && max1.x >= min2.x) &&
                    (min1.y <= max2.y && max1.y >= min2.y) &&
                    (min1.z <= max2.z && max1.z >= min2.z))
                {
                    amount = (int) value;
                }
            }
        }
    }
    if (cloak && shoot)
    {

        if ((g_pUserCmd->buttons & IN_ATTACK) && !bWasHolding &&
            HasCondition<TFCond_Cloaked>(LOCAL_E))
        {
            g_pUserCmd->buttons &= ~IN_ATTACK;
            g_pUserCmd->buttons |= IN_ATTACK2;
            amount = 2 * 90;
        }
        else if (CanShoot() && bIsHolding && !bWasHolding &&
                 g_pLocalPlayer->weapon()->m_iClassID != CL_CLASS(CTFFlareGun))
            amount = 1 * 90;
        else if (CanShoot() && bIsHolding && !bWasHolding &&
                 g_pLocalPlayer->weapon()->m_iClassID == CL_CLASS(CTFFlareGun))
            amount = 2 * 90;
        else if (bWasHolding && !bIsHolding)
            amount = 1 * 90;

        bWasHolding = (g_pUserCmd->buttons & IN_ATTACK) ||
                      (g_pUserCmd->buttons & IN_ATTACK2);
    }
    else if (!cloak)
    {
        if (shoot)
        {
            if (not g_pLocalPlayer->holding_sniper_rifle)
            {
                if (CanShoot() && bIsHolding && !bWasHolding &&
                    g_pLocalPlayer->weapon()->m_iClassID !=
                        CL_CLASS(CTFFlareGun))
                    amount = 1 * 90;
                else if (CanShoot() && bIsHolding && !bWasHolding &&
                         g_pLocalPlayer->weapon()->m_iClassID ==
                             CL_CLASS(CTFFlareGun))
                    amount = 2 * 90;
                else if (bWasHolding && !bIsHolding)
                    amount  = 1 * 90;
                bWasHolding = (g_pUserCmd->buttons & IN_ATTACK) ||
                              (g_pUserCmd->buttons & IN_ATTACK2);
            }
            else
            {
                bIsHolding = (g_pUserCmd->buttons & IN_ATTACK);
                if (CanShoot() && bIsHolding && !bWasHolding)
                    amount = 1 * 90;
                else if (bWasHolding && !bIsHolding)
                    amount  = 1 * 90;
                bWasHolding = (g_pUserCmd->buttons & IN_ATTACK);
            }
        }
    }
    else if (!shoot)
    {
        if (cloak)
        {
            if ((g_pUserCmd->buttons & IN_ATTACK2) && !bWasHolding &&
                !HasCondition<TFCond_Cloaked>(LOCAL_E))
            {
                amount = 1 * 90;
            }

            if ((g_pUserCmd->buttons & IN_ATTACK) && !bWasHolding &&
                HasCondition<TFCond_Cloaked>(LOCAL_E))
            {
                g_pUserCmd->buttons &= ~IN_ATTACK;
                g_pUserCmd->buttons |= IN_ATTACK2;
                amount = 2 * 90;
            }
            bWasHolding = (g_pUserCmd->buttons & IN_ATTACK) ||
                          (g_pUserCmd->buttons & IN_ATTACK2);
        }
    }

    if (key.KeyDown() || exticks || toggle)
        amount = int(value);

    // Thanks Wheaties For help!
    if (stickyspam)
    {
        if (g_pLocalPlayer->weapon()->m_iClassID == (CL_CLASS(CTFCannon)) ||
            g_pLocalPlayer->weapon()->m_iClassID ==
                (CL_CLASS(CTFPipebombLauncher)))
        {
            static bool bSwitch = false;
            bSwitch             = !bSwitch;
            if ((g_pUserCmd->buttons & IN_ATTACK) && bSwitch)
            {
                amount = 1 * 50;
                g_pUserCmd->buttons &= ~IN_ATTACK;
            }
        }
    }
    static int charge = 0;
    if (g_pLocalPlayer->bAttackLastTick && infinitecharge &&
        g_pLocalPlayer->weapon()->m_iClassID ==
            (CL_CLASS(CTFPipebombLauncher)) &&
        (g_pUserCmd->buttons & IN_ATTACK) &&
        CE_BYTE(LOCAL_W, netvar.m_flChargeLevel))
    {
        charge++;
        if (charge > 5)
            amount = (int) value;
    }
    else if (!(g_pUserCmd->buttons & IN_ATTACK))
        charge = 0;
    if (instant_weapon_switch && not HasCondition<TFCond_Cloaked>(LOCAL_E))
    {
        if (lastwep != g_pLocalPlayer->weapon()->m_iClassID)
        {
            amount  = 4 * 66;
            lastwep = g_pLocalPlayer->weapon()->m_iClassID;
        }
    }
    // SHOUTOUTS TO BLACKFIRE
    if (doom || razorback)
    {
        // Variablse to store Primary and secondary nextfire times
        static float i  = 0.0;
        static float i2 = 0.0;
        // Servertime to predict the next Primary and secondary times in seconds
        servertime =
            (float) (CE_INT(g_pLocalPlayer->entity, netvar.nTickBase)) *
            g_GlobalVars->interval_per_tick;
        // If not the holding the same weapon as last tick or i(2) is smaller
        // than 0.1f
        // Get a new nextattack(2)
        if (!nextattack || i < 0.1f ||
            g_pLocalPlayer->weapon()->m_iClassID != lastwep)
            nextattack =
                CE_FLOAT(g_pLocalPlayer->weapon(), netvar.flNextPrimaryAttack);
        if (!nextattack2 || i2 < 0.1f ||
            g_pLocalPlayer->weapon()->m_iClassID != lastwep)
            nextattack2 = CE_FLOAT(g_pLocalPlayer->weapon(),
                                   netvar.flNextSecondaryAttack);
        // If the next attack (2) time would exceed 75 seconds, set it to 75 to
        // prevent
        // The server disconnecting you for lagging too much
        if (servertime - nextattack > 75.0f)
            nextattack = servertime - 75.0f;
        if (servertime - nextattack2 > 75.0f)
            nextattack2 = servertime - 75.0f;
        // If doom is active and nextattack is positive (not reloading/holding
        // m1 since a while)
        // and you are holding m1 run the Doom code
        if (doom && servertime - nextattack > 0.0f &&
            (g_pUserCmd->buttons & IN_ATTACK ||
             g_pUserCmd->buttons & IN_ATTACK2))
        {
            // Incase i ever goes below 0.1 recalculate it (or if it's just
            // inited)
            if (i < 0.1f)
                i = servertime - (int) nextattack;
            // Set amount to i * 66 (which lags for i seconds)
            amount = i * 66;
            // Don't attack if the clip is empty so you also instantly reload
            if (!CE_BYTE(g_pLocalPlayer->weapon(), netvar.m_iClip1))
            {
                g_pUserCmd->buttons &= ~IN_ATTACK;
                g_pUserCmd->buttons &= ~IN_ATTACK2;
            }
        }
        // if anti-razorback is active and you can stab through the shieled
        if (razorback && servertime - nextattack > 3.0f &&
            (g_pUserCmd->buttons & IN_ATTACK))
        {
            CachedEntity *snoiper = nullptr;
            for (int ii = 0; ii < g_IEngine->GetMaxClients(); ii++)
            {
                CachedEntity *snooiper = ENTITY(ii);
                // nullptr and dormant check
                if (CE_BAD(snooiper))
                    continue;
                // Alive check
                if (!snooiper->m_bAlivePlayer)
                    continue;
                // Vischeck
                if (!VisCheckEntFromEnt(LOCAL_E, snooiper))
                    continue;
                // Range should be more than high enough
                if (!snooiper->m_flDistance < 200.0f)
                    continue;
                int clazz = CE_INT(snooiper, netvar.iClass);
                if (clazz != tf_sniper)
                    continue;
                // found entity
                snoiper = snooiper;
                // Break if you found an Entity, no need to go on further
                // checking
                break;
            }
            // Return if no snipers were found
            if (CE_BAD(snoiper))
                return;
            // Only works with knife out obviously
            if (g_pLocalPlayer->weapon()->m_iClassID == CL_CLASS(CTFKnife))
            {
                if (!i)
                    i  = 3;
                amount = i * 66;
                g_pUserCmd->buttons |= IN_ATTACK;
            }
        }
        // If i is not below 0.1f then substract one from it to slowly decrease
        // lag amount
        if (i > 0.1f)
            i -= 1.0f;
        // Set last weapon classid
        lastwep = g_pLocalPlayer->weapon()->m_iClassID;
    }
    // if Jarate spam active
    if (piss)
    {
        // Get Servertime
        servertime =
            (float) (CE_INT(g_pLocalPlayer->entity, netvar.nTickBase)) *
            g_GlobalVars->interval_per_tick;
        // Get nextattack when it's invalid or the player selected another
        // weapon (which is a tick, not a time like 1 second, but servertime + 1
        // second)
        if (!nextattack || g_pLocalPlayer->weapon()->m_iClassID != lastwep)
            nextattack =
                CE_FLOAT(g_pLocalPlayer->weapon(), netvar.flNextPrimaryAttack);
        // Set last weapon since it's not needed anymore this cycle
        lastwep = g_pLocalPlayer->weapon()->m_iClassID;
        // Check if holding JARAAATE
        if (CE_INT(g_pLocalPlayer->weapon(), netvar.iItemDefinitionIndex) == 58)
        {
            // Setup Switch variable to not constantly spam jarate, since else
            // the jarate may vanish
            static int bSwitch = 0;
            // Only play Piss.wav once every second
            if ((g_pUserCmd->command_number % 66) == 0 &&
                (g_pUserCmd->buttons & IN_ATTACK))
                announcer::playsound("piss.wav");
            // If in attack and bSwitch is 0 do not attack but increment bSwitch
            if ((g_pUserCmd->buttons & IN_ATTACK) && !bSwitch)
            {
                bSwitch++;
                g_pUserCmd->buttons &= ~IN_ATTACK;
            }
            // Else attack and set bSwitch to 0 once it's over 20
            else if (bSwitch)
            {
                amount = 21 * 66;
                bSwitch++;
                if (bSwitch > 20)
                    bSwitch = 0;
            }
        }
    }
    if (!amount)
        return;
    active = true;
    /*g_pUserCmd->command_number += amount;
    g_pUserCmd->hasbeenpredicted = true;
    *(int *) ((unsigned) g_IBaseClientState + offsets::lastoutgoingcommand()) +=
        amount;*/
    INetChannel *ch = (INetChannel *) g_IEngine->GetNetChannelInfo();
    int &m_nOutSequenceNr =
        *(int *) ((unsigned) ch + offsets::m_nOutSequenceNr());
    m_nOutSequenceNr += amount;
    //*bSendPackets = true;
}
void Draw()
{
#if ENABLE_VISUALS
    if (doom && (servertime - nextattack > 0.0f))
    {
        auto amount = servertime - nextattack;
        if (amount > 0.0f)
            AddCenterString(format("Fireable amount: ", (int) amount),
                            colors::orange);
    }
    if (razorback)
    {
        if (servertime - nextattack > 3.0f)
        {
            AddCenterString(format("Can Stab through Razorback"),
                            colors::green);
        }
        else if (servertime - nextattack < 3.0f)
            AddCenterString(format("Can't Stab through Razorback"),
                            colors::red);
    }
    if (piss)
    {
        if (servertime - nextattack > 21.0f)
        {
            AddCenterString(format("Can Spam piss"), colors::green);
        }
        else if (servertime - nextattack < 21.0f)
            AddCenterString(format("Can't spam piss, ",
                                   (int) ((servertime - nextattack) * 100 / 21),
                                   "% charge"),
                            colors::red);
    }
#endif
}
}
}
}
